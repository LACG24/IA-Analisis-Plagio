[
    {
        "codigo_1": "def dai(board,count,b,c,ms):\n    score = -10000\n    for i in range(9):\n        if board[i] != 0: continue\n        board[i] = 1\n        score = max(score, ko(list(board),count,b,c,ms))\n        board[i] = 0\n    return score\n\ndef ko(board,count,b,c,ms):\n    if count == 5: return calc(board,b,c,ms)\n    score = 10000\n    for i in range(9):\n        if board[i] != 0: continue\n        board[i] = -1\n        score = min(score,dai(list(board),count+1,b,c,ms))\n        board[i] = 0\n    return score\n\ndef main():\n    board = [0]*9\n    b = list(map(int,input().split()))\n    b.extend(list(map(int,input().split())))\n    c = list(map(int,input().split()))\n    c.extend(list(map(int,input().split())))\n    c.extend(list(map(int,input().split())))\n    score = 0\n    for i in range(6):\n        score += b[i] + c[i]\n    sa = dai(board,1,b,c,score)\n    dais = (score + sa)//2\n    kos = (score - sa)//2\n    print(dais)\n    print(kos)\n\nmain()",
        "codigo_2": "from collections import defaultdict\nfrom itertools import product\nfrom math import pi\nimport copy\n\nb, c = None, None\n\ndef calc_score(field):\n    score = 0\n    for y in range(3):\n        for x in range(3):\n            if y + 1 < 3 and field[y][x] == field[y + 1][x]:\n                score += b[y][x]\n            if x + 1 < 3 and field[y][x] == field[y][x + 1]:\n                score += c[y][x]\n    return score\n\nmemo = {}\n\ndef lt(l):\n    return tuple(l[0]), tuple(l[1]), tuple(l[2])\n\ndef dfs(i, field):\n    if i >= 9:\n        return calc_score(field)\n\n    if lt(field) in memo:\n        return memo[lt(field)]\n\n    mark = i % 2\n    best_score = 0 if mark == 0 else 10 ** 10\n    for y in range(3):\n        for x in range(3):\n            if field[y][x] is None:\n                field[y][x] = mark\n                score = dfs(i + 1, field)\n                field[y][x] = None\n\n                if mark == 0 and score > best_score:\n                    best_score = score\n                if mark == 1 and score < best_score:\n                    best_score = score\n\n    memo[lt(field)] = best_score\n    return best_score\n\ndef main():\n    global b, c\n    b1 = list(map(int, input().split()))\n    b2 = list(map(int, input().split()))\n    b = [b1, b2]\n    c1 = list(map(int, input().split()))\n    c2 = list(map(int, input().split()))\n    c3 = list(map(int, input().split()))\n    c = [c1 + [0], c2 + [0], c3 + [0]]\n\n    field = [[None] * 3 for _ in range(3)]\n    score = dfs(0, field)\n    total = sum([sum(x) for x in b + c])\n    print(*[score, total - score], sep=\"\\n\")\n\nif __name__ == '__main__':\n    main()",
        "tipo_plagio": "4"
    },
    {
        "codigo_1": "import heapq\nimport math\n\ndef solve(xs, ys, xt, yt, N, a):\n    a.insert(0, [xs, ys, 0])\n    a.append([xt, yt, 0])\n    n = len(a)\n\n    def distance(i, j):\n        x1, y1, r1 = a[i]\n        x2, y2, r2 = a[j]\n        dx = x1 - x2\n        dy = y1 - y2\n        d = math.hypot(dx, dy)\n        d -= (r1 + r2)\n        if d < 0:\n            d = 0\n        return d\n\n    graph = []\n    for _ in range(n):\n        graph.append([])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = distance(i, j)\n            graph[i].append((j, d))\n            graph[j].append((i, d))\n\n    dist = []\n    for _ in range(n):\n        dist.append(float('inf'))\n    dist[0] = 0\n\n    pq = []\n    pq.append((0, 0))\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, cost in graph[u]:\n            if dist[v] > dist[u] + cost:\n                dist[v] = dist[u] + cost\n                heapq.heappush(pq, (dist[v], v))\n\n    return dist[-1]\n\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\na = []\nfor _ in range(N):\n    x, y, r = map(int, input().split())\n    a.append([x, y, r])\n\nprint(solve(xs, ys, xt, yt, N, a))",
        "codigo_2": "xs,ys,xt,yt=list(map(int,input().split()))\nN=int(input())\na=[]\nfor i in range(N):\n\ta.append(list(map(int,input().split())))\n\nclass Dijkstra(object):\n\t\"\"\"\n\tダイクストラ法,(N^2)\n\tステータス:distance(list),prev(list),size(int)\n\tdistancemap[i][j]->Distance of edge i to j\n\t\"\"\"\n\tdef __init__(self, distancemap, start):\n\t\tself.start=start\n\t\tself.size=len(distancemap)\n\t\tself.distance=[float(\"inf\") for x in range(self.size)]\n\t\tself.distance[start]=0\n\t\tself.prev=[0 for x in range(self.size)]\n\t\tself.prev[start]=-1\n\t\tyet=list(range(self.size))\n\t\tyet.remove(start)\n\t\tnow=start\n\t\twhile(yet!=[]):\n\t\t\tnearest_num=0\n\t\t\tnearest_dis=float(\"inf\")\n\t\t\tfor i in yet:\n\t\t\t\ttotal_dis=distancemap[now][i]+self.distance[now]\n\t\t\t\tself.distance[i]=min(total_dis, self.distance[i])\n\t\t\t\tif self.distance[i]<=nearest_dis:\n\t\t\t\t\tnearest_dis=self.distance[i]\n\t\t\t\t\tnearest_num=i\n\t\t\tyet.remove(nearest_num)\n\t\t\tself.prev[nearest_num]=now\n\t\t\tnow=nearest_num\n\n\tdef route(self,goal):\n\t\troute=[]\n\t\twhile(True):\n\t\t\troute.append(self.prev[goal])\n\t\t\tgoal=self.prev[goal]\n\t\t\tif goal==self.start:\n\t\t\t\tbreak\n\t\troute.reverse()\n\t\treturn(route)\n\nimport math\ndef solve(xs,ys,xt,yt,N,a):\n\ta.insert(0,[xs,ys,0])\n\ta.append([xt,yt,0])\n\tdef distance(i,j):\n\t\tx1=a[i][0]\n\t\ty1=a[i][1]\n\t\tr1=a[i][2]\n\t\tx2=a[j][0]\n\t\ty2=a[j][1]\n\t\tr2=a[j][2]\n\t\td=math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))-r1-r2\n\t\tif d<0:\n\t\t\td=0\n\t\treturn(d)\n\tdistancemap=[[0 for x in range(N+2)] for x in range(N+2)]\n\tfor i in range(N+2):\n\t\tfor j in range(N+2):\n\t\t\tif i>j:\n\t\t\t\tdistancemap[i][j]=distancemap[j][i]\n\t\t\telse:\n\t\t\t\tdistancemap[i][j]=distance(i,j)\n\n\td=Dijkstra(distancemap, 0)\n\treturn(d.distance.pop())\n\nprint(solve(xs, ys, xt, yt, N, a))",
        "tipo_plagio": "4"
    },
    {
        "codigo_1": "import math\nY, X, K = map(int, input().split())\na = [[0 if c==\"x\" else 1 for c in input()]for i in range(Y)]\n#a = [[1]*500 for i in range(500)]\n\nfor x in range(X):\n    fr = 0\n    for y in range(Y + 1):\n        if y == Y or a[y][x] == 0:\n            for i in range(math.ceil((y - fr) / 2)):\n                a[fr+i][x] = i+1\n                a[y-i-1][x] = i+1\n            fr = y + 1\n\ncount = 0\n_cnt = 0\nLEN = (K-1)*2 + 1\nfor y in range(K-1, Y-K+1):\n    fr = 0\n    cnt = a[y].count(0)\n    for i in range(cnt+1):\n        to = a[y].index(0, fr) if i < cnt else X-1\n        l = to - fr + 1\n        if l < LEN:\n            fr = to+1\n            continue\n        ok = 0\n        for j in range(l-LEN+1):\n            ok = max(0, ok-1)\n            _fr, _to = fr+j, fr+LEN-1+j\n            flag = True\n            flag2 = True\n            for k in range(ok, LEN):\n                c = k+1 if k < K else 2*K-k-1\n                now = a[y][_fr+k]\n                if now < c:\n                    flag = False\n                    break\n                elif k <= K-1 or flag2 and now >= K:\n                    ok = k\n                else:\n                    flag2 = False\n            if flag:\n                count += 1\n            else:\n                ok = 0\n        fr = to+1\nprint(count)",
        "codigo_2": "import math\nY, X, K = map(int, input().split())\na = [[0 if c==\"x\" else 1 for c in input()]for i in range(Y)]\n\nfor x in range(X):\n    fr = 0\n    for y in range(Y + 1):\n        if y == Y or a[y][x] == 0:\n            for i in range(math.ceil((y - fr) / 2)):\n                a[fr+i][x] = i+1\n                a[y-i-1][x] = i+1\n            fr = y + 1\n\nresult = 0\ndiamond_length = (K-1)*2 + 1\ndiamond_radius = K\nfor y in range(K-1, Y-K+1):\n    start = 0\n    cnt = a[y].count(0)\n    for i in range(cnt+1):\n        end = a[y].index(0, start) if i < cnt else X-1\n        range_length = end - start + 1\n\n        if range_length < diamond_length:\n            start = end+1\n            continue\n\n        checked = 0\n        for j in range(range_length-diamond_length+1):\n            checked = max(0, checked-1)\n            _start = start + j\n            is_creatable = True\n            flag = True\n\n            for k in range(checked, diamond_length):\n                req = k+1 if k < diamond_radius else 2*diamond_radius-k-1\n                now = a[y][_start+k]\n                if now < req:\n                    is_creatable = False\n                    break\n                elif k <= diamond_radius-1 or flag and now >= diamond_radius:\n                    checked = k\n                else:\n                    flag = False\n\n            if is_creatable:\n                result += 1\n        start = end + 1\nprint(result)",
        "tipo_plagio": "3"
    },
    {
        "codigo_1": "#!/usr/bin/python\n\nimport sets\nimport sys\n\ndef find(parent, x):\n    if parent[x] == x:\n        return x\n    else:\n        parent[x] = find(parent, parent[x])\n        return parent[x]\n\ndef union(parent, x, y):\n    find(parent, x)\n    find(parent, y)\n\n    if parent[x] != parent[y]:\n        parent[parent[y]] = parent[parent[x]]\n\ndef main(argv):\n    tokens = sys.stdin.readline().rstrip(\"\\n\").split()\n\n    while len(tokens) == 3:\n        n, k, l = [int(i) for i in tokens]\n\n        parent_roads = [int(i) for i in xrange(n)]\n        parent_railways = [int(i) for i in xrange(n)]\n\n        for i in xrange(k):\n            x, y = [int(i) for i in raw_input().split(\" \")]\n            union(parent_roads, x - 1, y - 1)\n\n        for i in xrange(l):\n            x, y = [int(i) for i in raw_input().split(\" \")]\n            union(parent_railways, x - 1, y - 1)\n\n        count = dict()\n        for i in xrange(n):\n            key = (find(parent_roads, i), find(parent_railways, i))\n            if not count.has_key(key):\n                count[key] = 0\n            count[key] += 1\n\n        results = []\n        for i in xrange(n):\n            key = (find(parent_roads, i), find(parent_railways, i))\n            results.append(str(count[key]))\n        print \" \".join(results)\n\n        tokens = sys.stdin.readline().rstrip(\"\\n\").split()\n\nif __name__ == \"__main__\":\n    main(sys.argv)",
        "codigo_2": "#!/usr/bin/python\n\nimport sets\nimport sys\n\ndef find(parent, x):\n    if parent[x] == x:\n        return x\n    else:\n        parent[x] = find(parent, parent[x])\n        return parent[x]\n\ndef union(parent, x, y):\n    parent_x = find(parent, x)\n    parent_y = find(parent, y)\n\n    if parent_x != parent_y:\n        parent[parent_y] = parent[parent_x]\n\ndef main(argv):\n    tokens = sys.stdin.readline().rstrip(\"\\n\").split()\n\n    while len(tokens) == 3:\n        n, k, l = [int(i) for i in tokens]\n\n        parent_roads = [int(i) for i in xrange(n)]\n        parent_railways = [int(i) for i in xrange(n)]\n\n        for i in xrange(k):\n            x, y = [int(i) for i in raw_input().split(\" \")]\n            union(parent_roads, x - 1, y - 1)\n\n        for i in xrange(l):\n            x, y = [int(i) for i in raw_input().split(\" \")]\n            union(parent_railways, x - 1, y - 1)\n\n        count = dict()\n        for i in xrange(n):\n            key = (find(parent_roads, i), find(parent_railways, i))\n            if not count.has_key(key):\n                count[key] = 0\n            count[key] += 1\n\n        results = []\n        for i in xrange(n):\n            key = (find(parent_roads, i), find(parent_railways, i))\n            results.append(str(count[key]))\n        print \" \".join(results)\n\n        tokens = sys.stdin.readline().rstrip(\"\\n\").split()\n\nif __name__ == \"__main__\":\n    main(sys.argv)",
        "tipo_plagio": "1"
    },
    
    {
        "codigo_1": "from collections import deque\nEMPTY = 0\nBLACK = 1\nWHITE = 2\nN = input()\nG = {i: [] for i in range(1, N+1)}\nfor i in range(N-1):\n    a, b = map(int, raw_input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nparent = {}\ndist = [N] * (N+1)\ndist[1] = 0\nque = deque([1])\nwhile len(que) > 0:\n    s = que.popleft()\n    for t in G[s]:\n        if dist[t] > dist[s]+1:\n            dist[t] = dist[s]+1\n            parent[t] = s\n            que.append(t)\n\ns = N\npath = [s]\nwhile s in parent:\n    path.append(parent[s])\n    s = parent[s]\npath = path[::-1]\n\ncolors = [EMPTY] * (N+1)\nn = len(path)\nque_black, que_white = deque(), deque()\nfor i in range(n):\n    if i % 2 == 0:\n        v = path[i/2]\n        colors[v] = BLACK\n        que_black.append(v)\n    else:\n        v = path[n-i/2-1]\n        colors[v] = WHITE\n        que_white.append(v)\n\ndef paint(que, c):\n    while len(que) > 0:\n        s = que.popleft()\n        for t in G[s]:\n            if colors[t] == EMPTY:        \n                colors[t] = c\n                que.append(t)\npaint(que_black, BLACK)\npaint(que_white, WHITE)\nscore = 0\nfor c in colors:\n    if c == BLACK:\n        score += 1\n    elif c == WHITE:\n        score -= 1\nprint \"Fennec\" if score > 0 else \"Snuke\"",
        "codigo_2": "EMPTY = 0\nBLACK = 1\nWHITE = 2\nN = input()\nG = {i: [] for i in range(1, N+1)}\nfor i in range(N-1):\n    a, b = map(int, raw_input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nparent = {}\ndist = [N] * (N+1)\ndist[1] = 0\nque = [1]\nwhile len(que) > 0:\n    s = que.pop(0)\n    for t in G[s]:\n        if dist[t] > dist[s]+1:\n            dist[t] = dist[s]+1\n            parent[t] = s\n            que.append(t)\n\ns = N\npath = [s]\nwhile s in parent:\n    path.append(parent[s])\n    s = parent[s]\npath = path[::-1]\n\ncolors = [EMPTY] * (N+1)\nn = len(path)\nque_black, que_white = [], []\nfor i in range(n):\n    if i % 2 == 0:\n        v = path[i/2]\n        colors[v] = BLACK\n        que_black.append(v)\n    else:\n        v = path[n-i/2-1]\n        colors[v] = WHITE\n        que_white.append(v)\n\ndef paint(que, c):\n    while len(que) > 0:\n        s = que.pop(0)\n        for t in G[s]:\n            if colors[t] == EMPTY:        \n                colors[t] = c\n                que.append(t)\npaint(que_black, BLACK)\npaint(que_white, WHITE)\nscore = 0\nfor c in colors:\n    if c == BLACK:\n        score += 1\n    elif c == WHITE:\n        score -= 1\nprint \"Fennec\" if score > 0 else \"Snuke\"",
        "tipo_plagio": "1"
    },
     {
        "codigo_1": "def solve1():\n\tmaxx = maxy = 0\n\tminx = miny = 1000111000\n\tfor i in xrange(n):\n\t\tmaxx = max(maxx, x[i])\n\t\tminx = min(minx, x[i])\n\t\tmaxy = max(maxy, y[i])\n\t\tminy = min(miny, y[i])\n\treturn (maxx-minx)*(maxy-miny)\n\ndef solve2a(minx):\n\tminy = min(x)\n\tmaxy = max(y)\n\tmaxx = 0\n\t\n\tfor i in xrange(n):\n\t\tif y[i] < minx:\n\t\t\treturn 2**60\n\t\tif minx <= x[i]:\n\t\t\tmaxx = max(maxx, x[i])\n\t\telse:\n\t\t\tmaxx = max(maxx, y[i])\n\treturn (maxx-minx)*(maxy-miny)\n\ndef solve2_():\n\tres = 2**60\n\tfor minx in x:\n\t\tres = min(res, solve2a(minx))\n\tfor minx in y:\n\t\tres = min(res, solve2a(minx))\n\treturn res\n\ndef solve2():\n\tres = 2**60\n\txy = x+y\n\txy.sort()\n\tminy = min(x)\n\tmaxy = max(y)\n\tmy = min(y)\n\t\n\tpi = 0\n\tfor minx in xy:\n\t\tif my < minx:\n\t\t\tbreak\n\t\twhile pi < n and p[pi][0] < minx:\n\t\t\tpi += 1\n\t\tmaxx = max(ly[pi], rx[pi+1])\n\t\tres = min(res, (maxx-minx)*(maxy-miny))\n\treturn res\n\nn = int(raw_input())\n\nx = [0]*n\ny = [0]*n\np = [(0,0)]*n\nmini = maxi = 0\nfor i in xrange(n):\n\tx[i],y[i] = map(int, raw_input().split())\n\tx[i],y[i] = min(x[i],y[i]),max(x[i],y[i])\n\tp[i] = x[i],y[i]\n\tif x[i] < x[mini]:\n\t\tmini = i\n\tif y[maxi] < y[i]:\n\t\tmaxi = i\np.sort()\nly = [0]*(n+2)\nrx = [0]*(n+2)\nmx = my = 0\nfor i in xrange(n):\n\tmy = max(my, p[i][1])\n\tly[i+1] = my\n\nfor i in xrange(n-1,-1,-1):\n\tmx = max(mx, p[i][0])\n\trx[i+1] = mx\n\nans = solve1()\nif mini != maxi:\n\tans = min(ans, solve2())\nprint ans\n",
        "codigo_2": "#for t in xrange(int(raw_input())):\n#n,m = map(int, raw_input().split())\n#n = int(raw_input())\n\ndef solve1():\n\tmaxx = maxy = 0\n\tminx = miny = 1000111000\n\tfor i in xrange(n):\n\t\tmaxx = max(maxx, x[i])\n\t\tminx = min(minx, x[i])\n\t\tmaxy = max(maxy, y[i])\n\t\tminy = min(miny, y[i])\n\treturn (maxx-minx)*(maxy-miny)\n\ndef solve2a(minx):\n\tminy = min(x)\n\tmaxy = max(y)\n\tmaxx = 0\n\t\n\tfor i in xrange(n):\n\t\tif y[i] < minx:\n\t\t\treturn 2**60\n\t\tif minx <= x[i]:\n\t\t\tmaxx = max(maxx, x[i])\n\t\telse:\n\t\t\tmaxx = max(maxx, y[i])\n\treturn (maxx-minx)*(maxy-miny)\n\ndef solve2_():\n\tres = 2**60\n\tfor minx in x:\n\t\tres = min(res, solve2a(minx))\n\tfor minx in y:\n\t\tres = min(res, solve2a(minx))\n\treturn res\n\ndef solve2():\n\tres = 2**60\n\txy = x+y\n\txy.sort()\n\tminy = min(x)\n\tmaxy = max(y)\n\tmy = min(y)\n\tmx = max(x)\n\t\n\tpi = 0\n\tfor minx in xy:\n\t\tif my < minx:\n\t\t\tbreak\n\t\twhile pi < n and p[pi][0] < minx:\n\t\t\tpi += 1\n\t\tmaxx = max(ly[pi], mx)\n\t\tres = min(res, (maxx-minx)*(maxy-miny))\n\treturn res\n\nn = int(raw_input())\n\nx = [0]*n\ny = [0]*n\np = [(0,0)]*n\nmini = maxi = 0\nfor i in xrange(n):\n\tx[i],y[i] = map(int, raw_input().split())\n\tx[i],y[i] = min(x[i],y[i]),max(x[i],y[i])\n\tp[i] = x[i],y[i]\n\tif x[i] < x[mini]:\n\t\tmini = i\n\tif y[maxi] < y[i]:\n\t\tmaxi = i\np.sort()\nly = [0]*(n+2)\nmy = 0\nfor i in xrange(n):\n\tmy = max(my, p[i][1])\n\tly[i+1] = my\n\nans = solve1()\nif mini != maxi:\n\tans = min(ans, solve2())\nprint ans\n",
        "tipo_plagio": "3"
    },
    {
        "codigo_1": "# 結局は木+1辺\nfrom collections import defaultdict\nimport heapq as hq\n\nN = int(input())\nP = list(map(lambda x:int(x)-1,input().split()))\nD = [0]*N\nfor p in P:\n  D[p] += 1\n\nchild_L = defaultdict(list)\n\nS = [p for p in range(N) if D[p] == 0]\nL = [None]*N\n\nwhile S:\n  n = S.pop()\n\n  q = child_L[n]\n  del child_L[n]\n\n  hq.heapify(q)\n  i = 0\n  while q:\n    t = hq.heappop(q)\n    if i < t:\n      break\n    else:\n      i += (i==t)\n  \n  L[n] = i\n  m = P[n]\n  child_L[m].append(i)\n  D[m] -= 1\n  if D[m] == 0:\n    S.append(m)\n\n# cycle check\ntry:\n  start = D.index(1)\nexcept ValueError:\n  print('POSSIBLE')\n  exit()\n\ndef helper(n):\n  q = child_L[n]\n  del child_L[n]\n  \n  hq.heapify(q)\n  i = 0\n  while q:\n    t = hq.heappop(q)\n    if i < t:\n      break\n    else:\n      i += (i==t)\n\n  j = i+1\n  while q:\n    t = hq.heappop(q)\n    if j < t:\n      break\n    else:\n      j += (j==t)\n\n  return (i,j)\n\n\ns1,s2 = helper(start)\nG = []\nn = P[start]\nwhile n != start:\n  G.append(helper(n))\n  n = P[n]\n\n\ndel N,P,D,child_L,S,L\n\n\n# 可能な初期値をそれぞれシミュレート\n# 1\nn = s1\nfor g in G:\n  if g[0] == n:\n    n = g[1]\n  else:\n    n = g[0]\nif n != s1:\n  print('POSSIBLE')\n  exit()\n\n# 2\nn = s2\nfor g in G:\n  if g[0] == n:\n    n = g[1]\n  else:\n    n = g[0]\nif n == s1:\n  print('POSSIBLE')\n  exit()\n\nprint('IMPOSSIBLE')",
        "codigo_2": "from collections import defaultdict\nimport heapq as hq\n\n\ndef helper(n):\n    q = child_L[n]\n    del child_L[n]\n\n    hq.heapify(q)\n    i = 0\n    while q:\n        t = hq.heappop(q)\n        if i < t:\n            break\n        else:\n            i += (i == t)\n\n    j = i + 1\n    while q:\n        t = hq.heappop(q)\n        if j < t:\n            break\n        else:\n            j += (j == t)\n\n    return (i, j)\n\n\nif __name__ == '__main__':\n\n    N = int(input())\n    P = list(map(lambda x: int(x) - 1, input().split()))\n    # D:出している辺の本数\n    D = [0] * N\n    for p in P:\n        D[p] += 1\n    # print(D)\n    child_L = defaultdict(list)\n    # S:辺を出してないものリスト\n    S = [p for p in range(N) if D[p] == 0]\n\n    L = [None] * N\n\n    while S:\n        # print(child_L)\n        n = S.pop()\n\n        q = child_L[n]\n        # print(q)\n        del child_L[n]\n\n        # listのqをヒープキューに変換\n        hq.heapify(q)\n        i = 0\n        while q:\n            t = hq.heappop(q)\n            if i < t:\n                break\n            else:\n                i += (i == t)\n\n        L[n] = i\n        # print(L)\n        m = P[n]\n        # print(\"m:\" + str(m))\n        child_L[m].append(i)\n        D[m] -= 1\n        if D[m] == 0:\n            S.append(m)\n\n    # print(D)\n    # cycle check\n    try:\n        start = D.index(1)\n    except ValueError:\n        print('POSSIBLE')\n        exit()\n\n    s1, s2 = helper(start)\n    G = []\n    n = P[start]\n    while n != start:\n        G.append(helper(n))\n        n = P[n]\n\n    # del N, P, D, child_L, S, L\n\n    # 可能な初期値をそれぞれシミュレート\n    # 1\n    n = s1\n    for g in G:\n        if g[0] == n:\n            n = g[1]\n        else:\n            n = g[0]\n    if n != s1:\n        print('POSSIBLE')\n        exit()\n\n    # 2\n    n = s2\n    for g in G:\n        if g[0] == n:\n            n = g[1]\n        else:\n            n = g[0]\n    if n == s1:\n        print('POSSIBLE')\n        exit()\n\n    print('IMPOSSIBLE')\n",
        "tipo_plagio": "2"
    },
    {
        "codigo_1": "# E\nN = int(input())\nP_list = list(map(int, input().split()))\nX_list = list(map(int, input().split()))\n\n# graph\nchild_list = [[] for _ in range(N+1)]\nfor i in range(2, N+1):\n    child_list[P_list[i-2]].append(i)\n\n# from root\n# minimize local total weight\n\ncolor1 = [0]+X_list\ncolor2 = [0]*(N+1)\n\n# solve knapsack\ndef solve_knapsack(L, M):\n    min_acc = sum([min(color1[j], color2[j]) for j in L])\n    if min_acc > M:\n        return -1\n    else:\n        add_can = M - min_acc\n        add_set = set([0])\n        for j in L:\n            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])\n            add_set_ = set(add_set)\n            for s in add_set:\n                if s + add_j <= add_can:\n                    add_set_.add(s + add_j)\n            add_set = add_set_\n        \n        total = sum([color1[j]+color2[j] for j in L])\n        return total - max(add_set) - min_acc\n\nres = \"POSSIBLE\"\n\nfor i in range(N, 0, -1):\n    if len(child_list[i]) == 0:\n        pass\n    elif len(child_list[i]) == 1:\n        j = child_list[i][0]\n        if min(color1[j], color2[j]) > X_list[i-1]:\n            res = \"IMPOSSIBLE\"\n            break\n        elif max(color1[j], color2[j]) > X_list[i-1]:\n            color2[i] = max(color1[j], color2[j])\n        else:\n            color2[i] = min(color1[j], color2[j])\n    else:\n        c2 = solve_knapsack(child_list[i], X_list[i-1])\n        if c2 < 0:\n            res = \"IMPOSSIBLE\"\n            break\n        else:\n            color2[i] = c2\n    \nprint(res)",
        "codigo_2": "\nfrom itertools import chain,product\n\nN = int(input())\n\nP = list(chain((0,), map(lambda x: int(x)-1,input().split())))\nX = list(map(int,input().split()))\n\nL = [list() for _ in range(N)]\n\ndebug = [None]*N\n\nfor i in reversed(range(N)):\n  p = P[i]\n  l = L[i]\n\n  x = X[i]\n\n  # len(l) < 10のとき全探索、それ以上はDP\n  if len(l) < 10:\n    m = -1\n    for s in product(*l):\n      n = sum(s)\n      if n <= x:\n        m = max(n,m)\n    if m == -1:\n      print('IMPOSSIBLE')\n      exit()\n    m = sum(chain.from_iterable(l)) - m\n  else:\n    offset = sum(min(t) for t in l)\n    x -= offset\n    if x < 0:\n      print('IMPOSSIBLE')\n      exit()\n    dp = [False]*(x+1)\n    dp[0] = True\n    s = 0\n    for a,b in l:\n      d = abs(a-b)\n      s += d\n      for j in reversed(range(x-d+1)):\n        dp[j+d] = dp[j+d] or dp[j]\n    m = x\n    while not dp[m]:\n      m -= 1\n    m = s-m\n    m += offset\n    x += offset\n\n  debug[i] = (x,m)\n  L[p].append((x,m))\n  L[i] = None\n\nprint('POSSIBLE')\n\n",
        "tipo_plagio": "0"
    }

]
